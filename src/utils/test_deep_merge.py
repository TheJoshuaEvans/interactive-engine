import unittest
from utils.deep_merge import deep_merge

# Function tests generated by GitHub Copilot
class TestDeepMerge(unittest.TestCase):
    """Comprehensive unit tests for the deep_merge function."""

    def test_merge_empty_dictionaries(self):
        """Test merging two empty dictionaries."""
        result = deep_merge({}, {})
        self.assertEqual(result, {})

    def test_merge_with_first_empty(self):
        """Test merging when first dictionary is empty."""
        dict2 = {"a": 1, "b": 2}
        result = deep_merge({}, dict2)
        self.assertEqual(result, {"a": 1, "b": 2})

    def test_merge_with_second_empty(self):
        """Test merging when second dictionary is empty."""
        dict1 = {"a": 1, "b": 2}
        result = deep_merge(dict1, {})
        self.assertEqual(result, {"a": 1, "b": 2})

    def test_merge_simple_no_overlap(self):
        """Test merging dictionaries with no overlapping keys."""
        dict1 = {"a": 1, "b": 2}
        dict2 = {"c": 3, "d": 4}
        result = deep_merge(dict1, dict2)
        self.assertEqual(result, {"a": 1, "b": 2, "c": 3, "d": 4})

    def test_merge_simple_with_overlap(self):
        """Test merging dictionaries with overlapping keys (non-dict values)."""
        dict1 = {"a": 1, "b": 2}
        dict2 = {"b": 3, "c": 4}
        result = deep_merge(dict1, dict2)
        self.assertEqual(result, {"a": 1, "b": 3, "c": 4})

    def test_merge_nested_no_overlap(self):
        """Test merging nested dictionaries with no overlapping keys."""
        dict1 = {"a": {"x": 1}}
        dict2 = {"b": {"y": 2}}
        result = deep_merge(dict1, dict2)
        self.assertEqual(result, {"a": {"x": 1}, "b": {"y": 2}})

    def test_merge_nested_with_overlap_shallow(self):
        """Test merging nested dictionaries with overlapping top-level keys."""
        dict1 = {"a": {"x": 1, "y": 2}}
        dict2 = {"a": {"y": 3, "z": 4}}
        result = deep_merge(dict1, dict2)
        self.assertEqual(result, {"a": {"x": 1, "y": 3, "z": 4}})

    def test_merge_deeply_nested(self):
        """Test merging deeply nested dictionaries."""
        dict1 = {"a": {"b": {"c": 1}}}
        dict2 = {"a": {"b": {"d": 2}}}
        result = deep_merge(dict1, dict2)
        self.assertEqual(result, {"a": {"b": {"c": 1, "d": 2}}})

    def test_merge_very_deep_nesting(self):
        """Test merging very deeply nested dictionaries."""
        dict1 = {"a": {"b": {"c": {"d": {"e": 1}}}}}
        dict2 = {"a": {"b": {"c": {"d": {"f": 2}}}}}
        result = deep_merge(dict1, dict2)
        self.assertEqual(result, {"a": {"b": {"c": {"d": {"e": 1, "f": 2}}}}})

    def test_override_non_dict_with_dict(self):
        """Test that dict value overrides non-dict value."""
        dict1 = {"a": 1}
        dict2 = {"a": {"x": 2}}
        result = deep_merge(dict1, dict2)
        self.assertEqual(result, {"a": {"x": 2}})

    def test_override_dict_with_non_dict(self):
        """Test that non-dict value overrides dict value."""
        dict1 = {"a": {"x": 1}}
        dict2 = {"a": 2}
        result = deep_merge(dict1, dict2)
        self.assertEqual(result, {"a": 2})

    def test_merge_with_none_values(self):
        """Test merging dictionaries containing None values."""
        dict1 = {"a": None, "b": 2}
        dict2 = {"a": 1, "c": None}
        result = deep_merge(dict1, dict2)
        self.assertEqual(result, {"a": 1, "b": 2, "c": None})

    def test_merge_with_list_values(self):
        """Test merging dictionaries containing list values."""
        dict1 = {"a": [1, 2, 3]}
        dict2 = {"a": [4, 5, 6]}
        result = deep_merge(dict1, dict2)
        self.assertEqual(result, {"a": [4, 5, 6]})

    def test_merge_with_string_values(self):
        """Test merging dictionaries containing string values."""
        dict1 = {"a": "hello", "b": "world"}
        dict2 = {"a": "goodbye", "c": "universe"}
        result = deep_merge(dict1, dict2)
        self.assertEqual(result, {"a": "goodbye", "b": "world", "c": "universe"})

    def test_merge_with_boolean_values(self):
        """Test merging dictionaries containing boolean values."""
        dict1 = {"a": True, "b": False}
        dict2 = {"b": True, "c": False}
        result = deep_merge(dict1, dict2)
        self.assertEqual(result, {"a": True, "b": True, "c": False})

    def test_merge_with_numeric_values(self):
        """Test merging dictionaries with various numeric types."""
        dict1 = {"int": 1, "float": 1.5}
        dict2 = {"int": 2, "float": 2.5, "negative": -10}
        result = deep_merge(dict1, dict2)
        self.assertEqual(result, {"int": 2, "float": 2.5, "negative": -10})

    def test_merge_mixed_depth(self):
        """Test merging dictionaries with mixed nesting depths."""
        dict1 = {
            "a": 1,
            "b": {"x": 2, "y": 3},
            "c": {"m": {"n": 4}}
        }
        dict2 = {
            "b": {"y": 5, "z": 6},
            "c": {"m": {"o": 7}},
            "d": 8
        }
        result = deep_merge(dict1, dict2)
        expected = {
            "a": 1,
            "b": {"x": 2, "y": 5, "z": 6},
            "c": {"m": {"n": 4, "o": 7}},
            "d": 8
        }
        self.assertEqual(result, expected)

    def test_merge_does_not_modify_input_dict1(self):
        """Test that the first input dictionary is not modified."""
        dict1 = {"a": 1, "b": {"x": 2}}
        dict1_copy = {"a": 1, "b": {"x": 2}}
        dict2 = {"b": {"y": 3}, "c": 4}
        deep_merge(dict1, dict2)
        self.assertEqual(dict1, dict1_copy)

    def test_merge_does_not_modify_input_dict2(self):
        """Test that the second input dictionary is not modified."""
        dict1 = {"a": 1, "b": {"x": 2}}
        dict2 = {"b": {"y": 3}, "c": 4}
        dict2_copy = {"b": {"y": 3}, "c": 4}
        deep_merge(dict1, dict2)
        self.assertEqual(dict2, dict2_copy)

    def test_merge_complex_nested_structure(self):
        """Test merging complex nested structures."""
        dict1 = {
            "config": {
                "settings": {
                    "display": {"width": 1920, "height": 1080},
                    "sound": {"volume": 50}
                },
                "user": {"name": "Alice"}
            }
        }
        dict2 = {
            "config": {
                "settings": {
                    "display": {"refresh_rate": 60},
                    "sound": {"volume": 75, "mute": False}
                },
                "user": {"email": "alice@example.com"}
            },
            "metadata": {"version": "1.0"}
        }
        result = deep_merge(dict1, dict2)
        expected = {
            "config": {
                "settings": {
                    "display": {"width": 1920, "height": 1080, "refresh_rate": 60},
                    "sound": {"volume": 75, "mute": False}
                },
                "user": {"name": "Alice", "email": "alice@example.com"}
            },
            "metadata": {"version": "1.0"}
        }
        self.assertEqual(result, expected)

    def test_merge_with_empty_nested_dicts(self):
        """Test merging with empty nested dictionaries."""
        dict1 = {"a": {}}
        dict2 = {"a": {"x": 1}}
        result = deep_merge(dict1, dict2)
        self.assertEqual(result, {"a": {"x": 1}})

    def test_merge_empty_nested_in_second(self):
        """Test merging when second dict has empty nested dictionary."""
        dict1 = {"a": {"x": 1}}
        dict2 = {"a": {}}
        result = deep_merge(dict1, dict2)
        self.assertEqual(result, {"a": {"x": 1}})

    def test_merge_multiple_levels_with_overrides(self):
        """Test merging multiple levels with various override scenarios."""
        dict1 = {
            "level1": {
                "level2a": {"keep": "this", "override": "old"},
                "level2b": "string"
            }
        }
        dict2 = {
            "level1": {
                "level2a": {"override": "new", "add": "this"},
                "level2c": {"new": "dict"}
            }
        }
        result = deep_merge(dict1, dict2)
        expected = {
            "level1": {
                "level2a": {"keep": "this", "override": "new", "add": "this"},
                "level2b": "string",
                "level2c": {"new": "dict"}
            }
        }
        self.assertEqual(result, expected)

    def test_merge_with_numeric_keys(self):
        """Test merging dictionaries with numeric keys."""
        dict1 = {1: "one", 2: "two"}
        dict2 = {2: "TWO", 3: "three"}
        result = deep_merge(dict1, dict2)
        self.assertEqual(result, {1: "one", 2: "TWO", 3: "three"})

    def test_merge_preserves_data_types(self):
        """Test that merging preserves different data types correctly."""
        dict1 = {
            "string": "text",
            "int": 42,
            "float": 3.14,
            "bool": True,
            "none": None,
            "list": [1, 2, 3],
            "dict": {"nested": "value"}
        }
        dict2 = {"extra": "field"}
        result = deep_merge(dict1, dict2)

        self.assertIsInstance(result["string"], str)
        self.assertIsInstance(result["int"], int)
        self.assertIsInstance(result["float"], float)
        self.assertIsInstance(result["bool"], bool)
        self.assertIsNone(result["none"])
        self.assertIsInstance(result["list"], list)
        self.assertIsInstance(result["dict"], dict)

    def test_merge_no_arguments(self):
        """Test merging with no arguments."""
        result = deep_merge()
        self.assertEqual(result, {})

    def test_merge_single_dictionary(self):
        """Test merging with a single dictionary."""
        dict1 = {"a": 1, "b": 2}
        result = deep_merge(dict1)
        self.assertEqual(result, {"a": 1, "b": 2})
        # Ensure it's a copy, not the same object
        self.assertIsNot(result, dict1)

    def test_merge_three_dictionaries(self):
        """Test merging three dictionaries."""
        dict1 = {"a": 1, "b": 2}
        dict2 = {"b": 3, "c": 4}
        dict3 = {"c": 5, "d": 6}
        result = deep_merge(dict1, dict2, dict3)
        self.assertEqual(result, {"a": 1, "b": 3, "c": 5, "d": 6})

    def test_merge_four_dictionaries(self):
        """Test merging four dictionaries with nested structures."""
        dict1 = {"a": {"x": 1, "y": 2}}
        dict2 = {"a": {"y": 3, "z": 4}}
        dict3 = {"b": {"m": 5}}
        dict4 = {"a": {"z": 6}, "b": {"n": 7}}
        result = deep_merge(dict1, dict2, dict3, dict4)
        expected = {
            "a": {"x": 1, "y": 3, "z": 6},
            "b": {"m": 5, "n": 7}
        }
        self.assertEqual(result, expected)

    def test_merge_multiple_with_empty_dicts(self):
        """Test merging multiple dictionaries including empty ones."""
        dict1 = {"a": 1}
        dict2 = {}
        dict3 = {"b": 2}
        dict4 = {}
        dict5 = {"c": 3}
        result = deep_merge(dict1, dict2, dict3, dict4, dict5)
        self.assertEqual(result, {"a": 1, "b": 2, "c": 3})

    def test_merge_multiple_complex_nested(self):
        """Test merging multiple dictionaries with complex nested structures."""
        dict1 = {
            "config": {
                "settings": {"display": {"width": 1920}},
                "user": {"name": "Alice"}
            }
        }
        dict2 = {
            "config": {
                "settings": {"display": {"height": 1080}},
                "user": {"age": 30}
            }
        }
        dict3 = {
            "config": {
                "settings": {"display": {"refresh_rate": 60}},
                "user": {"email": "alice@example.com"}
            }
        }
        result = deep_merge(dict1, dict2, dict3)
        expected = {
            "config": {
                "settings": {
                    "display": {"width": 1920, "height": 1080, "refresh_rate": 60}
                },
                "user": {"name": "Alice", "age": 30, "email": "alice@example.com"}
            }
        }
        self.assertEqual(result, expected)

    def test_merge_multiple_with_overrides(self):
        """Test that later dictionaries override earlier ones."""
        dict1 = {"value": 1}
        dict2 = {"value": 2}
        dict3 = {"value": 3}
        dict4 = {"value": 4}
        result = deep_merge(dict1, dict2, dict3, dict4)
        self.assertEqual(result, {"value": 4})

    def test_merge_multiple_does_not_modify_inputs(self):
        """Test that merging multiple dictionaries doesn't modify any inputs."""
        dict1 = {"a": {"x": 1}}
        dict2 = {"a": {"y": 2}}
        dict3 = {"a": {"z": 3}}

        dict1_copy = {"a": {"x": 1}}
        dict2_copy = {"a": {"y": 2}}
        dict3_copy = {"a": {"z": 3}}

        deep_merge(dict1, dict2, dict3)

        self.assertEqual(dict1, dict1_copy)
        self.assertEqual(dict2, dict2_copy)
        self.assertEqual(dict3, dict3_copy)

    def test_merge_multiple_left_to_right_order(self):
        """Test that dictionaries are merged in left-to-right order."""
        dict1 = {"a": {"x": 1, "y": 1}}
        dict2 = {"a": {"y": 2, "z": 2}}
        dict3 = {"a": {"z": 3, "w": 3}}
        result = deep_merge(dict1, dict2, dict3)
        expected = {"a": {"x": 1, "y": 2, "z": 3, "w": 3}}
        self.assertEqual(result, expected)

    def test_merge_five_plus_dictionaries(self):
        """Test merging many dictionaries."""
        dicts = [{"key": i} for i in range(10)]
        result = deep_merge(*dicts)
        self.assertEqual(result, {"key": 9})

    def test_merge_multiple_with_none_dicts(self):
        """Test merging when some arguments might be None or empty."""
        dict1 = {"a": 1}
        dict2 = {}
        dict3 = {"b": 2}
        result = deep_merge(dict1, dict2, dict3)
        self.assertEqual(result, {"a": 1, "b": 2})


if __name__ == "__main__":
    unittest.main()
